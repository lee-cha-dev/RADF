import fs from "node:fs";
import path from "node:path";

const root = process.cwd();
const stylesDir = path.join(root, "src", "framework", "styles");
const outDir = path.join(stylesDir, "__generated__");
const outFile = path.join(outDir, "inlineStyles.js");

const isCss = (p) => p.toLowerCase().endsWith(".css");

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];

  for (const ent of entries) {
    // Skip generated output to avoid self-inclusion
    if (ent.name === "__generated__") continue;

    const abs = path.join(dir, ent.name);
    if (ent.isDirectory()) {
      files.push(...walk(abs));
    } else if (ent.isFile() && isCss(abs)) {
      files.push(abs);
    }
  }

  return files;
}

function relFromStyles(absPath) {
  return path.relative(stylesDir, absPath).replace(/\\/g, "/");
}

// Stable priority ordering for known “base” files + themes.
// Everything else is alphabetical.
function sortCss(relPaths) {
  const priority = (rel) => {
    const lower = rel.toLowerCase();

    // base tokens/palettes/framework first
    if (lower === "tokens.css") return 0;
    if (lower === "palettes.css") return 1;
    if (lower === "framework.css") return 2;

    // components next
    if (lower.startsWith("components/")) return 3;

    // themes after components, prefer light then dark
    if (lower === "theme.light.css") return 4;
    if (lower === "theme.dark.css") return 5;
    if (lower.startsWith("theme.")) return 6;

    // everything else
    return 7;
  };

  return [...relPaths].sort((a, b) => {
    const pa = priority(a);
    const pb = priority(b);
    if (pa !== pb) return pa - pb;

    // within same bucket, alphabetical
    return a.localeCompare(b);
  });
}

function buildCssBundle(sortedRelPaths) {
  const chunks = [];

  for (const rel of sortedRelPaths) {
    const abs = path.join(stylesDir, rel);
    const css = fs.readFileSync(abs, "utf8");

    chunks.push(`/* ---- ${rel} ---- */\n${css}\n`);
  }

  return chunks.join("\n");
}

function writeGeneratedModule(cssText, fileList) {
  fs.mkdirSync(outDir, { recursive: true });

  const content =
    `/**\n` +
    ` * GENERATED FILE — DO NOT EDIT.\n` +
    ` * Generated by scripts/gen-inline-styles.mjs\n` +
    ` *\n` +
    ` * Included CSS files (in order):\n` +
    fileList.map((f) => ` * - ${f}\n`).join("") +
    ` */\n\n` +
    `export const RADF_INLINE_CSS = ${JSON.stringify(cssText)};\n`;

  fs.writeFileSync(outFile, content, "utf8");
}

if (!fs.existsSync(stylesDir)) {
  console.error(`[radf] styles dir not found: ${stylesDir}`);
  process.exit(1);
}

const absFiles = walk(stylesDir);
const relFiles = absFiles.map(relFromStyles);

if (relFiles.length === 0) {
  console.error("[radf] no CSS files found under src/framework/styles");
  process.exit(1);
}

const sorted = sortCss(relFiles);
const cssText = buildCssBundle(sorted);
writeGeneratedModule(cssText, sorted);

console.log(`[radf] wrote ${path.relative(root, outFile)} (${sorted.length} CSS files)`);
